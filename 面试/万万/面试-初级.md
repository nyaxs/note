
###抽象类和接口的区别？
1）抽象类继承于object接口不继承object.  
2）抽象类有构造器，接口中没有构造器.   
3）抽象类中可以有普通成员变量和常量，接口中只能有常量，而且只能是public static final 不写默认。  
4）抽象类中可以有抽象方法，也可以有普通的方法，接口中只能有抽象的方法而且修饰符只能是public abstract 不写默认。    
5）抽象类中可以有final的方法,接口中不能有final的方法。   
6）抽象类只能是单继承，多实现，接口是可以多继承其他接口，但是不能实现接口，和不能继承其他类。 
7）抽象类中可以有静态的方法，接口中不可以。  
8） 抽象类是is –a的关系，接口是like –a 的关系  


###final有哪些用法?
final也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了:   
被final修饰的类不可以被继承    
被final修饰的方法不可以被重写   
被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.   
被final修饰的方法,JVM会尝试将其内联,以提高运行效率  
被final修饰的常量,在编译阶段会存入常量池中.   


###String,StringBuffer和StringBuilder区别?
String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);StringBuilder 字符串变量(线程不安全).此外StringBuilder和StringBuffer实现原理一样,都是基于数组扩容来实现的.


###==和equals的区别
1)对于==，比较的是值是否相等        
如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，     
如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。        
其实==比较的不管是基本数据类型，还是引用数据类型的变量，比较的都是值，只是引用类型变量存的值是对象的地址       
2)对于equals方法，比较的是是否是同一个对象       
首先，equals()方法不能作用于基本数据类型的变量，        
另外，equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，  
所以说所有类中的equals()方法都继承自Object类，在没有重写equals()方法的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向的对象的地址，       
不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。            
        
会调用对象的 equals 方法，如果对象的 equals 方法没有被重写，equals 方法和==都是比较 栈内局部变量表中指向堆内存地址值是否相等     
总结：equals相等则hashcode一定相等，hashcode相等，equals不一定相等。   

###堆(heap)和栈(stack)里的区别 
1、申请方式的不同。栈由系统自动分配，而堆是人为申请开辟;   
2、申请大小的不同。栈获得的空间较小，而堆获得的空间较大;   
3、申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢;      
4、存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排;     
5、底层不同。栈是连续的空间，而堆是不连续的空间。  


###char和varchar的区别
char类型的长度是固定的，varchar的长度是可变的。   
char类型的效率比varchar的效率稍高      
varchar2是oracle开发的一个数据类型    
char最多可以存放255个字符,varchar的最大长度为65535个字节      
每次修改的数据长度不同，为了效率应当考虑用char定长代替varchar2变长 


###什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作
对象序列化，将对象以二进制的形式保存在硬盘上      
反序列化；将二进制的文件转化为对象读取     
实现serializable接口，不想让字段放在硬盘上就加transient      
实现序列化接口,接口会默认生成一个serialVersionUID,建议自定义一个serialVersionUID,不然反序列化可能会报异常


###static都有哪些用法?
静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.  
除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:
public calss PreCache{  
    static{     
        //执行相关操作            
    }   
}   
此外static也多用于修饰内部类,此时称之为静态内部类.   


###java中实现多态的机制是什么？    
重写、重载、父类的声明指向子类的对象。 


###final finally finalize
final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表      
示该变量是一个常量不能被重新赋值。       
finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块        
中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。      
finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调      
用，当我们调用 System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的        
最后判断。


###反射的理解
对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能 调用它的任意一个方法和属性

###Java中创建对象的5种方式
1.new对象;    
2.QuartzJobEntity.class.newInstance();  
3.QuartzJobEntity.class.getConstructor();    
4.new ObjectInputStream.readObject();//反序列化    
5.(QuartzJobEntity) quartzJobEntity.clone();//克隆        

**Overload和Override的区别。**   
（Overload）重载：发生在同一个类之中，方法名相同、参数列表不同，与返回值无关、与final无关、与修饰符无关、与异常无关。   
（Override）重写：发生在子类和父类之间，方法名相同、参数列表相同、返回值相同、不能是final的方法、重写的方法不能有比父类方法更为严格的修饰符权限、重写的方法所抛出的异常不能比父类的更大。 

###服务器优化
**tomcat内存优化:**     
看应用大小，如果你的war包就有200多M，那你xms至少都要1G，而且最好把permGen设置到512M,其次可以根据项目使用人数,代码情况,MQ使用情况再去判断   
catalina.sh 中设置 java_OPTS 参数。   
JAVA_OPTS参数说明   
-server 启用jdk 的 server 版；   
-Xms java虚拟机初始化时的最小内存；  
-Xmx java虚拟机可使用的最大内存；   
-XX: PermSize 内存永久保留区域  
-XX:MaxPermSize 内存最大永久保留区域      
服务器参数配置：
现公司服务器内存一般都可以加到最大2G ，所以可以采取以下配置：
JAVA_OPTS=’-Xms1024m -Xmx2048m -XX: PermSize=256M -XX:MaxNewSize=256m -XX:MaxPermSize=256m’     

**tomcat并发优化:**
配置tomcat安装目录下的configs/server.xml,调整连接器connector的并发处理能力  
1）配置示例      
<Connector port="9027"   protocol="HTTP/1.1"    
maxHttpHeaderSize="8192"     
maxThreads="1000"  
minSpareThreads="100"   
maxSpareThreads="1000"  
minProcessors="100" 
maxProcessors="1000"    
enableLookups="false"   
URIEncoding="utf-8" 
acceptCount="1000"  
redirectPort="8443"
disableUploadTimeout="true"/>  
2)参数说明  
maxThreads 客户请求最大线程数    
minSpareThreads Tomcat初始化时创建的 socket 线程数    
maxSpareThreads Tomcat连接器的最大空闲 socket 线程数   
enableLookups 若设为true, 则支持域名解析，可把 ip 地址解析为主机名   
redirectPort 在需要基于安全通道的场合，把客户请求转发到基于SSL 的 redirectPort 端口   
acceptAccount 监听端口队列最大数，满了之后客户请求会被拒绝（不能小于maxSpareThreads ）  
connectionTimeout 连接超时  
minProcessors 服务器创建时的最小处理线程数    
maxProcessors 服务器同时最大处理线程数  
URIEncoding URL统一编码 

**tomcat缓存优化**    
1）参数说明  
compression 打开压缩功能  
compressionMinSize 启用压缩的输出内容大小，这里面默认为2KB    
compressableMimeType 压缩类型   
connectionTimeout 定义建立客户连接超时的时间. 如果为 -1, 表示不限制建立客户连接的时间 

###servlet  
主要用于响应HTTP请求。Servlet一般用于mvc中的控制器部分。 
Servlet生命周期分为实例化、初始化、响应请求调用service()方法、消亡阶段调用destroy()方法。   
执行过程如下： 
1）当浏览器发送一个请求地址，tomcat会接收这个请求    
2）tomcat会读取项目中的web.xml中的配置  
3）当请求地址符合servlet-mapping标签映射的地址，会进入这个servlet    
4）servlet首先会实例化（构造），然后初始化执行init()方法，init()方法至始至终执行一次，servlet对象是单实例  
5）根据请求的方式是get或post，在service()方法中调用doget()或dopost()方法，完成此次请求 
6）当服务器停止，会调用destroy()方法，销毁实例    
1）第一次请求时，实例化servlet对象   
2）在web.XML文件中的<Servlet></Servlet>之间添加<loadon-startup>1</loadon-startup>，tomcat启动时就会实例化servlet对象     
**创建servlet的3中方式**  
一、实现javax.servlet.Servlet接口
二、继承javax.servet.GenericServlet类    
三、继承javax.servlet.http.HttpServlet类

###session 和 application的区别？
1）两者的作用范围不同：    
Session对象是用户级的，而Application是应用程序级别的     
一个用户一个session对象，每个用户的session对象不同，在用户所访问的网站多个页面之间共享同一个session对象  
一个Web应用程序一个application对象，每个Web应用程序的application对象不同，但一个Web应用程序的多个用户之间共享同一个application对象。 
两者的生命周期不同：  
session对象的生命周期：用户首次访问网站创建，用户离开该网站 (不一定要关闭浏览器) 消亡。也可以在web.xml中设置session的过期时间。当超出过期时间后亦会消亡。   
application对象的生命周期：启动Web服务器创建，关闭Web服务器销毁。       

###Cookied和session区别？   
1）cookie数据存放在客户的浏览器上，session数据放在服务器上。   
2）cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。    
3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。  
4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。    

**Filter的生命周期与执行过程**
生命周期如下： 
1、执行构造方法，实例化    
2、执行init方法，初始化  
3、执行doFilter方法，过滤用户请求   
4、当tomcat关闭时，执行destroy方法，进行销毁   
构造方法与init方法在tomcat启动时就执行，至始至终只执行一次， 
filter对象是单实例    
执行过程如下： 
1、浏览器发送一个请求，会到达tomcat   
2、tomcat会根据项目中的web.xml中的Filter过滤路径配置，过滤请求   
3、过滤到用户请求会进入Filter类中的doFilter方法 
4、在doFilter方法中实现业务逻辑，最后调用doFilter(request, response)    
传递用户请求  
5、到达用户请求的页面     

**触发器** 
触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。 
可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。     

**存储过程**        
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。  
如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 
优点： 
1）存储过程是预编译过的，执行效率高。 
2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。  
3）安全性高，执行存储过程需要有一定权限的用户。        
4）存储过程可以重复使用，可减少数据库开发人员的工作量。      

**索引**  
索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。索引可以是唯一的，   
创建索引允许指定单个列或者是多个列。  
缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小   
缺点：移植性差     
1、经常被查询的字段          
2、不为空且字段值不重复        
3、字段的值不经常被修改
逻辑上：    
Single column 单行索引  
Concatenated 多行索引   
Unique 唯一索引 
NonUnique 非唯一索引 
Function-based函数索引  
Domain 域索引  
物理上：    
Partitioned 分区索引    
NonPartitioned 非分区索引    
B-tree：                  
Normal 正常型B树    
Rever Key 反转型B树 
Bitmap 位图索引 


**视图的优缺点**  
优点：     
1）对数据库的访问，因为视图可以有选择性的选取数据库里的一部 分。    
2）用户通过简单的查询可以从复杂查询中得到结果。    
3）维护数据的独立性，视图可从多个表检索数据。     
4）对于相同的数据可产生不同的视图。      
缺点： 
性能：查询视图时，必须把视图的查询转化成对基本表的查询，
如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，也把它变成一个复杂的结合体，需要花费一定的时间。   

**在数据库中查询语句速度很慢，如何优化？**     
1.建索引   
2.减少表之间的关联  
3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据	量大的表排在前面    
4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据    
5.尽量用PreparedStatement来查询，不要用Statement      

**线程**  
synchronized关键字
调用sleep不会释放对象锁,sleep 方法属于 Thread 类中方法
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁,必须要采用 notify() 和 notifyAll() 方法
唤醒该进程       
currentThread()方法是获取当前线程
interrupt()唤醒休眠线程，  
创建线程有三种方式：  
1）是继承Thread类，创建格式如下：    
Thread thread = new Thread();   
2）是实现Runnable接口，创建格式如下： 
Thread thread = new Thread(new Runnable()); 
其实Thread类实现了Runnable接口  
3）通过线程池方式，获取线程  
newFixedThreadPool()        
4)通过 Callable 和 Future 创建线程     

###线程状态    
1）新建状态（New）：新创建了一个线程对象。 
2）就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。    
3）运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。   
4）阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。   
5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。   




**List、Set和Map的区别？**    
1）List和Set是Collection的子接口,map不是。    
2）List的底层是数组的方式实现，Set是散列表的方式实现，map是键值对的方式。  
3）list是有序可重复的，Set是无序不可重复的，map是有序，key不重复，value可重复    
4）list和Set可直接使用itertator来进行遍历，map只能通过先遍历Key在遍历value.  
5）set检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变      

###Collection和Collections区别
java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法     
java.util.Collections 是针对集合类的一个帮助类  

###HashSet 是如何保证不重复的
不仅要比较hash值，同时还要结合 equles 方法比较


**hibernate**       
ORM是对象关系映射,类—>表，属性—>表中的列,对象—>表中的每一条数据,  
是为了解决面向对象与关系数据库之间互不匹配现象的技术  
1）hibernate是ORM框架，ORM是对象关系映射,类—>表，属性—>表中的列,对象—>表中的每一条数据，是为了解决面向对象与关系数据库之间互不匹配现象的技术。使我们编程的思想更面向对象了，不用去考虑关系型数据库。  
2）hibernate工作流程是：configuration类读取并解析hibernate.cfg.xml配置文件，读取解析映射信息，创建sessionFactory，打开session，创建事务，持久化操作，关闭session，整个应用停止关闭sessionFactory。  
3）结合hibernate优点说明：  
a、程序更加面向对象，提高开发效率   
b、提高了生产率，不用写SQL语句   
c、hibernate使用的是hql，支持方言配置，方便数据库移植   
d、对jdbc代码进行封装，编程更简便了    
e、hibernate是个轻量级框架，对代码无侵入性  
缺点： 
1）效率比JDBC略差     
2）不适合批量操作   
3）对表的操作不够灵活 

1）瞬时状态（临时状态）：当new 对象时候，处于瞬时状态（如果程序运行完了，该对象会被垃圾回收）。  
2）持久状态	：跟session有关，就是持久状态，持久状态的对象，任何的修改，都会影响到数据库中与之对应的数据。  
3）托管状态（游离状态）：当session不在管理对象的时候，脱离了	session 的管理 
延迟加载：   
1）推迟的时间内由于没有数据加载可以节约内存空间，提高内存的使用率。  
2）如果对象查询出来并没有使用，那么延迟加载的对象根本没有访问数据库，可以减少数据可得访问次数。    

**Sping**       
1）Sping是一个轻量级框架,Sping核心是IOC容器(控制反转)和AOP(面向切面的编程),IOC是用来管理控制对象的生命周期和对象之间的关系，通过配置文件进行注入，很好的实现了对象与对象之间解耦。  
2）IOC工作原理： IOC实现了工厂模式，通过读取application.xml配置文件中的<bean>标签的类，注入到IOC容器中，通过构造或set方法注入，产生BeanFactory，BeanFactory通过getBean方法获取对象。  
3）AOP面向切面编程，可以动态的将主线业务逻辑代码与实现功能代码分开，将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来。   
4）Spring提供了很多第三方框架的整合，如：hibernate、struts、mybatis、web service等，使用IOC管理所有的Java bean，这样可以让框架与框架之间偶尔度降低，方便项目的管理，提高开发效率。     
5）MVC框架,事务管理,异常管理       

ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。    
@Required  注解   
这个注解表明bean的属性必须在配置的时候设置，通过bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。  
@Autowired 注解   
@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。     
@Qualifier 注解   
当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。        

如何通俗地理解三大范式？    
第一范式：表中每个字段都不能再分。
第二范式：满足第一范式并且表中的非主键字段都依赖于主键字段。
第三范式：满足第二范式并且表中的非主键字段必须不传递依赖于主键字段，每一列 数据和主键直接相关。

Spring框架提供了以下5中类型通知.    
1）.前置通知<aop:before> 
方面功能在目标方法之前调用.  
2）后置通知<aop:afterReturning>  
方面功能在目标方法之后调用.(如果目标方法抛出异常则不会执行方面功能) 
3）最终通知<aop:after>   
方面功能在目标方法之后调用.(目标方法有无异常都会执行方面功能)    
4）环绕通知<aop:around>  
方面功能在目标方法之前和之后调用.   
5）异常通知<aop:afterThrowing>   
方面功能在目标方法抛出异常之后调用.      
Spring四种依赖注入方式，常用1、2种，  
1）Set方法注入       
2）构造器注入     
3）静态工厂方法注入  
4）实例工厂方法注入  

**spring mvc的工作原理**  
（1）用户发送请求至前端控制器DispatcherServlet；   
（2）DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler；   
（3）处理器映射器根据请求url找到具体的处理器Handler，生成处理器对象及处理器拦截器(如果有则生成)，一并返回给DispatcherServlet；  
（4）DispatcherServlet 调用 HandlerAdapter处理器适配器，请求执行Handler；   
（5）HandlerAdapter 经过适配调用 具体处理器进行处理业务逻辑；     
（6）Handler执行完成返回ModelAndView；   
（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；  
（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；   
（9）ViewResolver解析后返回具体View；     
（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）      
（11）DispatcherServlet响应用户。      

Spring MVC 启动流程
> 在 web.xml 文件中给 Spring MVC 的 Servlet 配置了 load-on-startup,所以程序启动的       
> 时候会初始化 Spring MVC，在 HttpServletBean 中将配置的 contextConfigLocation       
> 属性设置到 Servlet 中，然后在 FrameworkServlet 中创建了 WebApplicationContext,      
> DispatcherServlet 根据 contextConfigLocation 配置的 classpath 下的 xml 文件初始化     
> Spring MVC 总的组件              

springmvc是单例的，线程不安全 
@scope  
spring中bean的scope属性，有如下5种类型：    
singleton 表示在spring容器中的单例，通过spring容器获得该bean时总是返回唯一的实例   
prototype表示每次获得bean都会生成一个新的对象   
request表示在一次http请求内有效（只适用于web应用）    
session表示在一个用户会话内有效（只适用于web应用）  
globalSession表示在全局会话内有效（只适用于web应用）  

###mybatis的工作原理    
1）SqlSessionFactoryBuilder类读取mybatis-config.xml配置文件     
2）读取解析Mapper.xml映射文件，创建SqlSessionFactory     
3）打开SqlSession  
4）持久化操作     
5）提交事务  
6）关闭session 

###Mapper工作原理
Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK     
动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而      
执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回      

###mybatis怎么分页的
Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内      
存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分     
页功能，也可以使用分页插件来完成物理分页。       

###Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
第一种是使用<resultMap>标签，逐一定义数据库列名和对象属性名之间的映射关系。        
第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名。        
有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给             
对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。     

###Mybaits的优点？
（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。      
（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；      
（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。     
（4）能够与Spring很好的集成；  
（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。  
缺点:     
（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。     
（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。     

###MyBatis与Hibernate有哪些不同？
（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。        
（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。              
（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。        

###Mybatis动态sql有什么用？执行原理？有哪些动态sql？
答：Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。     
Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。       


###Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？ 
答：<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。      

###为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。       

###MyBatis实现一对一有几种方式?具体怎么操作的？
答：有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；     
嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。      

###MyBatis实现一对多有几种方式,怎么操作的？
答： 有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置       

###Mybatis的一级、二级缓存:
答：1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。       
2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；      
3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。       

###spring和springmvc的区别         
Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。  
这两个核心，可以单独用于任何应用。   
spring mvc类似于struts的一个MVC开框架，其实都是属于spring，spring mvc需要有spring的架包作为支撑才能跑起来。  

###$和#区别   
####{}: 解析为一个 JDBC 预编译语句（prepared statement）的参数标记符，一个 #{ } 被解析为一个参数占位符 。可以防止sql注入。 
${}: 仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换。   
Restful:URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。我们熟悉的springmvc框架就可以实现restful风格架构。 
    
###多线程和高并发问题怎么解决？    
首先要了解多线程高并发的的瓶颈在哪里？     
1、可能是服务器网络带宽不够      
2.可能web线程连接数不够      
3.可能数据库连接查询上不去。     
4．数据产生脏读等       
1）增加网络带宽，DNS域名解析分发多台服务器。        
2）负载均衡，前置代理服务器nginx、apache等等        
3）数据库查询优化，读写分离，分表等等         
4）尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。         
5）优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。  
6）能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）           
7）避免产生脏读可以设置事务的隔离级别和java代码或数据库加锁。       
    
**sql查询是否走索引**  
3、使用Explain plan for 命令。    
1）执行 “explain plan for  要执行的Sql语句;” 
2）执行 “select * from table(DBMS_XPLAN.display);”查看结果。    

**GET方法**   
GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据,且不安全  

**POST方法**  
POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求 

**HEAD方法**  
HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容 

**PUT方法**   
用上传的内容替换目标资源中的所有当前内容    

**DELETE方法**    
DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。       

**CONNECT方法**   
CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信   

ServletContext类的application对象：主要用于保存用户信息，代码片段的运行环境；它是一个共享的内置对象，即一个容器中的多个用户共享一个application
，故其保存的信息被所有用户所共享       

**乐观锁**：
认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，更新数据的时候去判断之前有没有别的线程更新了这个数据，如果这个数据没有被更新，       
当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则执行其他操作，如报错或自动重试。    
乐观锁最常用的是CAS算法，java java.util.concurrent包下的原子类(例如AtomicBoolean，AtomicInteger，AtomicLong) 
中的递增操作通过CAS自旋来实现。   

**悲观锁**：它是对于并发操作时产生的线程安全持悲观心态，悲观锁认为竞争总会发生，因此每次对于某些进行操作时，都会持有一个独占的锁，像synchronied和lock的实现类都是悲观锁。  

**Spring Cloud Netflix**    
Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。 
Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；    
Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；        
Hystrix：客户端容错保护，特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离。    
Feign：基于Ribbon和Hystrix的声明式服务调用组件；       
Zuul：API网关组件，对请求提供路由及过滤功能。          
Stream: 消息驱动，有Sink、Source、Processor三种通道，特性有订阅发布、消费组、消息分区。       
Bus:消息总线，配合Config仓库修改的⼀种Stream实现            
Config: 分布式配置中⼼，⽀持本地仓库、SVN、Git、Jar包内配置等模式       
Sleuth:分布式服务追踪，需要搞清楚TraceID和SpanID以及抽样，如何与ELK整合。
**spring常用注解**  
@PropertySource     导入properties文件  
@Configuration  标明该类是一个配置类  
@Component：一般写在类上边，通过该注解将当前类初始化到Spring的IOC容器中，其他类若想调用，直接用@Autowired去容器中拿        
@Role       
bean角色定义为ROLE_APPLICATION(默认值)、ROLE_SUPPORT(辅助角色)、ROLE_INFRASTRUCTURE(后台角色，用户无感)    
@Scope  
指定bean的作用域，默认singleton，其它包括prototype、request、session、globalSession      
@Lazy   
使bean懒加载，取消bean预初始化。    
@Required   检查bean的属性setXXX()方法，要求属性配置阶段必须已配置,自动装配,注解的bean属性未被设置,会报异 BeanInitializationException    
@Autowired  注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。   
@ModelAttribute 可被应用在方法和方法参数上。              
@RestController ：@ResponseBody和@Controller的合集。      
@EnableAutoConfiguration ：尝试根据你添加的jar依赖⾃动配置你的Spring应⽤。          
@ComponentScan：表示将该类⾃动发现（扫描）并注册为Bean，可以⾃动收集所有的Spring组件，包括@Configuration类。       
@ImportResource ：⽤来加载xml配置⽂件。       
@Configuration ：相当于传统的xml配置⽂件，如果有些第三⽅库需要⽤到xml⽂件，建议仍然通过@Configuration类作为项⽬       
的配置主类——可以使⽤@ImportResource注解加载xml配置⽂件。
@SpringBootApplication：相当于@EnableAutoConfiguration、@ComponentScan和@Configuration的合集     
@Qualifier: 有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。

###幻读,脏读,不可重复读
脏读（Dirty reads）—— 事务 A读取B更新  b回滚,A读取脏数据
不可重复读（Nonrepeatable read）—— 事务A多次提交,B读取进行了更新提交,A多次读取时结果不一致      
幻读（Phantom read）—— A在改结果,当事务B插入数据,A改结果有一条未改过来


###说说spring事物的传播性和隔离级别
a. 七个事传播属性：
1. propagation_required -- ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。
2. propagation_supports -- ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。
3. propagation_mandatory  -- ⽀持当前事务，如果当前没有事务，就抛出异常。
4. propagation_requiresnew -- 新建事务，如果当前存在事务，把当前事务挂起。
5. propagation_notsupported -- 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。
6. propagation_never - 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。
7. propagation_nested - 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与
   propagation_required类似的操作。
   b. 五个隔离级别：
1. ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.
2. 另外四个与JDBC的隔离级别相对应：
3. ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种
   隔离级别会产⽣脏读，不可重复读和幻读。
4. ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务
   未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。
5. ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务
   不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。
6. ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不
   可重复读外，还避免了幻读。

###spring中的设计模式：
a. 简单⼯⼚：spring中的BeanFactory就是简单⼯⼚模式的体现，根据传⼊⼀个
唯⼀的标识来获得bean对象，但是否是在传⼊参数后创建还是传⼊参数前创建这个
要根据具体情况来定。
b. 单例模式：Spring下默认的bean均为singleton。
c. 代理模式：为其他对象提供⼀种代理以控制对这个对象的访问。 从结构上来看
和Decorator模式类似，但Proxy是控制，更像是⼀种对功能的限制，⽽Decorator
是增加职责。 spring的Proxy模式在aop中有体现，⽐如JdkDynamicAopProxy和
Cglib2AopProxy。
d. 观察者模式：定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发⽣改变
时，所有依赖于它的对象都得到通知并被⾃动更新。spring中Observer模式常⽤的
地⽅是listener的实现。如ApplicationListener。        


**如何使用XML配置的方式配置Spring？**       
```
在Spring框架中，依赖和服务需要专门的配置文件中实现，我一般用XML格式的配置文件。这些配置文件的格式采用通公共的模板，由一系列的Bean定义和专门的应用配置选项组成。
Spring XML配置的主要目的是使所有的Spring组件都可以用XML文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）。
Spring的XML配置方式是使用被Spring命名空间所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。
<beans>
   <!-- JSON Support -->
<bean name="viewResolver"
class="org.springframework.web.servlet.view.BeanNameViewResolver"/>
<bean name="jsonTemplate"
class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
<bean id="restTemplate" class="org.springframework.web.client.RestTemplate"/>
</beans>

下面这个web.xml仅配置了DispatcherServlet，这最简单的配置便能满足应用程序配置运行时组件的需求。
<web-app>
<display-name>Archetype Created Web Application</display-name>
<servlet>
<servlet-name>spring</servlet-name>
<servlet-class>
org.springframework.web.servlet.DispatcherServlet
</servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
<servlet-name>spring</servlet-name>
<url-pattern>/</url-pattern>
</servlet-mapping>
</web-app>
```

**Spring Bean作用域的区别是什么？**   
Spring容器中的Bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下。         
（1）singleton：这种Bean范围是默认的，这种范围确保不管接收到多少个请求，每个容器中只有一个Bean的实例，单例的模式由Bean Factory自身来维护。       
（2）prototype：原形范围与单例范围相反，为每一个Bean请求提供一个实例。      
（3）request：在请求Bean范围内为每一个来自客户端的网络请求创建一个实例，在请求完成以后，Bean会失效并被垃圾回收器回收。      
（4）Session：与请求范围类似，确保每个Session中有一个Bean的实例，在Session过期后，Bean会随之失效。       
（5）global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量，那么这个全局变量需要存储在global-session中。全局作用域与Servlet中的Session作用域效果相同。       

###BeanFactory 和 ApplicationContext 有什么区别
BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，    
以便在接收到客户端请求时将对应的 bean 实例化。      
BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客  
户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始       
化方法（initialization methods）和销毁方法（destruction methods）。          
从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关   
系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。            
提供了支持国际化的文本消息         
统一的资源文件读取方式           
已在监听器中注册的 bean 的事件    

**请解释Spring Bean的生命周期？**    
Spring Bean的生命周期简单易懂。在一个Bean实例被初始化时，需要执行一系列初始化操作以达到可用的状态。同样，当一个Bean不再被调用时需要进行相关的析构操作，并从Bean容器中移除。   
Spring Bean Factory 负责管理在Spring容器中被创建的Bean的生命周期。Bean的生命周期由两组回调方法组成。  
（1）初始化之后调用的回调方法。     
（2）销毁之前调用的回调方法。       
Spring框架提供了以下四种方式来管理Bean的生命周期事件：    
（1）InitializingBean和DisposableBean回调接口。     
（2）针对特殊行为的其他Aware接口。    
（3）Bean配置文件中的Custom init()方法和destroy()方法。       
（4）@PostConstruct和@PreDestroy注解方式。          
使用customInit()和 customDestroy()方法管理Bean生命周期的代码样例如下：       
```
<beans> 
<bean id="demoBean" class="com.gupaoedu.task.DemoBean"  
init-Method="customInit" destroy-Method="customDestroy">    
</bean> 
</beans>    
```

###Spring IOC 如何实现      
> Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了       
Spring 框架 IoC 容器的基础。            
> BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。       
ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的      
基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message        
resource 的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的     
WebApplicationContext。 > org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，用       
来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。          

###Spring AOP 实现原理
> Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理。JDK 动态代     
理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK 动态代理的       
核心是 InvocationHandler 接口和 Proxy 类。      
> 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB      
（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类     
的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，      
那么它是无法使用 CGLIB 做动态代理的。              

###Spring 事务实现方式
（1）编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。        
（2）基于 TransactionProxyFactoryBean的声明式事务管理,基于 xml 配置文件的方式        
（3）基于 @Transactional 的声明式事务管理       
（4）基于Aspectj AOP配置事务        

###Spring 事务底层原理
1.调用ioc划分了事务处理单元,配置到ioc容器中              
2.AOP 拦截需要进行事务处理的类          
3.调用TransactionProxyFactoryBean接口,转换spring的内部数据结构       
4.spring 委托给具体的事务处理器实现。实现了一个抽象和适配,PlatformTransactionManager、AbstractPlatforTransaction 一系列事务处理的支持      
5.PlatformTransactionManager 实现了 TransactionInterception 接口，让其与
TransactionProxyFactoryBean 结合起来，形成一个 Spring 声明式事务处理的设计体系。      

###自定义注解实现功能
> 创建自定义注解和创建一个接口相似，但是注解的 interface 关键字需要以@符号开头 。        
> 注解方法不能带有参数；       
> 注解方法返回值类型限定为：基本类型、String、Enums、Annotation 或者是这些类型的        
数组；     
> 注解方法可以有默认值；       
> 注解本身能够包含元注解，元注解被用来注解其它注解。     

**为什么要用 Btree**     
1.Btree 索引是数据库中存取和查找文件(称为记录或键值)的一种方法。        
2.硬盘中的结点也是 Btree 结构的。与内存相比，硬盘必须花成倍的时间来存取一个数据元 素，这是因为硬盘的机械部件读写数据的速度远远赶不上纯电子媒体的内存。     
3.与一个结点两 个分支的二元树相比，Btree 利用多个分支（称为子树）的结点，减少获取记录时所经历的 结点数，从而达到节省存取时间的目的。     


**请举例说明如何在Spring中注入一个Java 集合？**     
```
Spring提供了以下四种集合类的配置元素：
（1）<list>标签用来装配可重复的list值。
（2）<set>标签用来装配没有重复的set值。
（3）<map>标签可用来注入键和值，可以为任何类型的键值对。
（4）<props>标签支持注入键和值都是字符串类型的键值对。
下面看一下具体的例子：
<beans>
<bean id="javaCollection" class="com.gupaoedu.JavaCollection">
<property name="customList">
<list>
<value>INDIA</value>
<value>Pakistan</value>
<value>USA</value>
<value>UK</value>
</list>
</property>
<property name="customSet">
<set>
<value>INDIA</value>
<value>Pakistan</value>
<value>USA</value>
<value>UK</value>
</set>
</property>
<property name="customMap">
<map>
<entry key="1" value="INDIA"/>
<entry key="2" value="Pakistan"/>
<entry key="3" value="USA"/>
<entry key="4" value="UK"/>
</map>
</property>
<property name="customProperies">
<props>
<prop key="admin">admin@gupaoedu.com</prop>
<prop key="support">support@gupaoedu.com</prop>
</props>
</property>
</bean>
</beans>
```

**Spring框架中的IOC容器**     
Spring中的org.springframework.beans包和org.springframework.context包构成了Spring框架IOC容器的基础。     
BeanFactory接口提供了一个先进的配置机制，使得任何类型的对象的配置都成为可能。ApplicationContext接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能        


###1、使用Spring框架的好处是什么？
答：轻量： Spring 是轻量的，基本的版本大约2MB。   
控制反转： Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。    
面向切面的编程(AOP)： Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 
容器： Spring 包含并管理应用中对象的生命周期和配置。  
MVC框架： Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。       
事务管理： Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。      
异常处理： Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。     
###2、 Spring由哪些模块组成?
答：以下是Spring 框架的基本模块：    
Core module 
Bean module 
Context module  
Expression Language module  
JDBC module 
ORM module  
OXM module  
Java Messaging Service(JMS) module  
Transaction module  
Web module  
Web-Servlet module  
Web-Struts module   
Web-Portlet module  

###3、BeanFactory – BeanFactory 实现举例。   
答：Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。    
最常用的BeanFactory 实现是XmlBeanFactory 类。        

###4、什么是Spring IOC 容器？
答：Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。
###5、IOC的优点是什么？
答：IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。     
###6、什么是基于注解的容器配置?
答：相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。      
开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。        


